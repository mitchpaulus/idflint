//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from Idd.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
[System.CLSCompliant(false)]
public partial class IddParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		T__0=1, T__1=2, GROUPSTATEMENT=3, AUTOCALCULATABLE_STATEMENT=4, AUTOSIZABLE_STATEMENT=5, 
		BEGIN_EXTENSIBLE_STATEMENT=6, DEFAULT_STATEMENT=7, DEPRECATED_STATEMENT=8, 
		EXTENSIBLE_STATEMENT=9, EXTERNAL_LIST_STATEMENT=10, FIELD_STATEMENT=11, 
		FORMAT_STATEMENT=12, GROUP_STATEMENT=13, IP_UNITS_STATEMENT=14, KEY_STATEMENT=15, 
		MAXIMUM_EXCLUSIVE_STATEMENT=16, MAXIMUM_INCLUSIVE_STATEMENT=17, MEMO_STATEMENT=18, 
		MINIMUM_EXCLUSIVE_STATEMENT=19, MINIMUM_INCLUSIVE_STATEMENT=20, NOTE_STATEMENT=21, 
		OBJECT_LIST_STATEMENT=22, OBSOLETE_STATEMENT=23, REFERENCE_STATEMENT=24, 
		REFERENCE_CLASS_NAME_STATEMENT=25, REQUIRED_FIELD_STATEMENT=26, REQUIRED_OBJECT_STATEMENT=27, 
		RETAINCASE_STATEMENT=28, TYPE_STATEMENT=29, UNIQUE_OBJECT_STATEMENT=30, 
		UNITS_STATEMENT=31, INTEGER=32, ALPHA_OPTION=33, NUMERIC_OPTION=34, OBJECT_NAME=35, 
		COMMENT=36, FIELD_SEPARATOR=37, OBJECT_TERMINATOR=38, NEWLINE=39, WS=40;
	public const int
		RULE_idd = 0, RULE_object = 1, RULE_object_header = 2, RULE_fields = 3, 
		RULE_terminating_field = 4, RULE_field = 5, RULE_field_id = 6, RULE_group = 7, 
		RULE_object_properties = 8, RULE_field_properties = 9, RULE_object_property = 10, 
		RULE_field_property = 11, RULE_min_fields_statement = 12, RULE_units_based_on_field_statement = 13;
	public static readonly string[] ruleNames = {
		"idd", "object", "object_header", "fields", "terminating_field", "field", 
		"field_id", "group", "object_properties", "field_properties", "object_property", 
		"field_property", "min_fields_statement", "units_based_on_field_statement"
	};

	private static readonly string[] _LiteralNames = {
		null, "'\\min-fields '", "'\\unitsBasedOnField '", null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, "','", "';'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, "GROUPSTATEMENT", "AUTOCALCULATABLE_STATEMENT", "AUTOSIZABLE_STATEMENT", 
		"BEGIN_EXTENSIBLE_STATEMENT", "DEFAULT_STATEMENT", "DEPRECATED_STATEMENT", 
		"EXTENSIBLE_STATEMENT", "EXTERNAL_LIST_STATEMENT", "FIELD_STATEMENT", 
		"FORMAT_STATEMENT", "GROUP_STATEMENT", "IP_UNITS_STATEMENT", "KEY_STATEMENT", 
		"MAXIMUM_EXCLUSIVE_STATEMENT", "MAXIMUM_INCLUSIVE_STATEMENT", "MEMO_STATEMENT", 
		"MINIMUM_EXCLUSIVE_STATEMENT", "MINIMUM_INCLUSIVE_STATEMENT", "NOTE_STATEMENT", 
		"OBJECT_LIST_STATEMENT", "OBSOLETE_STATEMENT", "REFERENCE_STATEMENT", 
		"REFERENCE_CLASS_NAME_STATEMENT", "REQUIRED_FIELD_STATEMENT", "REQUIRED_OBJECT_STATEMENT", 
		"RETAINCASE_STATEMENT", "TYPE_STATEMENT", "UNIQUE_OBJECT_STATEMENT", "UNITS_STATEMENT", 
		"INTEGER", "ALPHA_OPTION", "NUMERIC_OPTION", "OBJECT_NAME", "COMMENT", 
		"FIELD_SEPARATOR", "OBJECT_TERMINATOR", "NEWLINE", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Idd.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static IddParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public IddParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public IddParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class IddContext : ParserRuleContext {
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public GroupContext[] group() {
			return GetRuleContexts<GroupContext>();
		}
		public GroupContext group(int i) {
			return GetRuleContext<GroupContext>(i);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(IddParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(IddParser.NEWLINE, i);
		}
		public IddContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_idd; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterIdd(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitIdd(this);
		}
	}

	[RuleVersion(0)]
	public IddContext idd() {
		IddContext _localctx = new IddContext(Context, State);
		EnterRule(_localctx, 0, RULE_idd);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 33;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << GROUPSTATEMENT) | (1L << COMMENT) | (1L << NEWLINE))) != 0)) {
				{
				State = 31;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case COMMENT:
					{
					State = 28; Match(COMMENT);
					}
					break;
				case GROUPSTATEMENT:
					{
					State = 29; group();
					}
					break;
				case NEWLINE:
					{
					State = 30; Match(NEWLINE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 35;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectContext : ParserRuleContext {
		public Object_headerContext object_header() {
			return GetRuleContext<Object_headerContext>(0);
		}
		public FieldsContext fields() {
			return GetRuleContext<FieldsContext>(0);
		}
		public ObjectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterObject(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitObject(this);
		}
	}

	[RuleVersion(0)]
	public ObjectContext @object() {
		ObjectContext _localctx = new ObjectContext(Context, State);
		EnterRule(_localctx, 2, RULE_object);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 36; object_header();
			State = 37; fields();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_headerContext : ParserRuleContext {
		public ITerminalNode OBJECT_NAME() { return GetToken(IddParser.OBJECT_NAME, 0); }
		public ITerminalNode FIELD_SEPARATOR() { return GetToken(IddParser.FIELD_SEPARATOR, 0); }
		public Object_propertiesContext object_properties() {
			return GetRuleContext<Object_propertiesContext>(0);
		}
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(IddParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(IddParser.NEWLINE, i);
		}
		public Object_headerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_header; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterObject_header(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitObject_header(this);
		}
	}

	[RuleVersion(0)]
	public Object_headerContext object_header() {
		Object_headerContext _localctx = new Object_headerContext(Context, State);
		EnterRule(_localctx, 4, RULE_object_header);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 39; Match(OBJECT_NAME);
			State = 40; Match(FIELD_SEPARATOR);
			State = 44;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 41;
					_la = TokenStream.LA(1);
					if ( !(_la==COMMENT || _la==NEWLINE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					} 
				}
				State = 46;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			}
			State = 47; object_properties();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldsContext : ParserRuleContext {
		public Terminating_fieldContext terminating_field() {
			return GetRuleContext<Terminating_fieldContext>(0);
		}
		public FieldContext[] field() {
			return GetRuleContexts<FieldContext>();
		}
		public FieldContext field(int i) {
			return GetRuleContext<FieldContext>(i);
		}
		public FieldsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fields; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterFields(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitFields(this);
		}
	}

	[RuleVersion(0)]
	public FieldsContext fields() {
		FieldsContext _localctx = new FieldsContext(Context, State);
		EnterRule(_localctx, 6, RULE_fields);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 52;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 49; field();
					}
					} 
				}
				State = 54;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			}
			State = 55; terminating_field();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Terminating_fieldContext : ParserRuleContext {
		public Field_idContext field_id() {
			return GetRuleContext<Field_idContext>(0);
		}
		public ITerminalNode OBJECT_TERMINATOR() { return GetToken(IddParser.OBJECT_TERMINATOR, 0); }
		public Field_propertiesContext field_properties() {
			return GetRuleContext<Field_propertiesContext>(0);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(IddParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(IddParser.NEWLINE, i);
		}
		public Terminating_fieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_terminating_field; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterTerminating_field(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitTerminating_field(this);
		}
	}

	[RuleVersion(0)]
	public Terminating_fieldContext terminating_field() {
		Terminating_fieldContext _localctx = new Terminating_fieldContext(Context, State);
		EnterRule(_localctx, 8, RULE_terminating_field);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 57; field_id();
			State = 58; Match(OBJECT_TERMINATOR);
			State = 62;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,4,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 59; Match(NEWLINE);
					}
					} 
				}
				State = 64;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,4,Context);
			}
			State = 65; field_properties();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldContext : ParserRuleContext {
		public Field_idContext field_id() {
			return GetRuleContext<Field_idContext>(0);
		}
		public ITerminalNode FIELD_SEPARATOR() { return GetToken(IddParser.FIELD_SEPARATOR, 0); }
		public Field_propertiesContext field_properties() {
			return GetRuleContext<Field_propertiesContext>(0);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(IddParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(IddParser.NEWLINE, i);
		}
		public FieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitField(this);
		}
	}

	[RuleVersion(0)]
	public FieldContext field() {
		FieldContext _localctx = new FieldContext(Context, State);
		EnterRule(_localctx, 10, RULE_field);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 67; field_id();
			State = 68; Match(FIELD_SEPARATOR);
			State = 72;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==NEWLINE) {
				{
				{
				State = 69; Match(NEWLINE);
				}
				}
				State = 74;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 75; field_properties();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_idContext : ParserRuleContext {
		public ITerminalNode ALPHA_OPTION() { return GetToken(IddParser.ALPHA_OPTION, 0); }
		public ITerminalNode NUMERIC_OPTION() { return GetToken(IddParser.NUMERIC_OPTION, 0); }
		public Field_idContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_id; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterField_id(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitField_id(this);
		}
	}

	[RuleVersion(0)]
	public Field_idContext field_id() {
		Field_idContext _localctx = new Field_idContext(Context, State);
		EnterRule(_localctx, 12, RULE_field_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			_la = TokenStream.LA(1);
			if ( !(_la==ALPHA_OPTION || _la==NUMERIC_OPTION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupContext : ParserRuleContext {
		public ITerminalNode GROUPSTATEMENT() { return GetToken(IddParser.GROUPSTATEMENT, 0); }
		public ObjectContext[] @object() {
			return GetRuleContexts<ObjectContext>();
		}
		public ObjectContext @object(int i) {
			return GetRuleContext<ObjectContext>(i);
		}
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public GroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitGroup(this);
		}
	}

	[RuleVersion(0)]
	public GroupContext group() {
		GroupContext _localctx = new GroupContext(Context, State);
		EnterRule(_localctx, 14, RULE_group);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 79; Match(GROUPSTATEMENT);
			State = 84;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 82;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case OBJECT_NAME:
						{
						State = 80; @object();
						}
						break;
					case COMMENT:
						{
						State = 81; Match(COMMENT);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 86;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_propertiesContext : ParserRuleContext {
		public Object_propertyContext[] object_property() {
			return GetRuleContexts<Object_propertyContext>();
		}
		public Object_propertyContext object_property(int i) {
			return GetRuleContext<Object_propertyContext>(i);
		}
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public Object_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_properties; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterObject_properties(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitObject_properties(this);
		}
	}

	[RuleVersion(0)]
	public Object_propertiesContext object_properties() {
		Object_propertiesContext _localctx = new Object_propertiesContext(Context, State);
		EnterRule(_localctx, 16, RULE_object_properties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 91;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__0) | (1L << EXTENSIBLE_STATEMENT) | (1L << FORMAT_STATEMENT) | (1L << MEMO_STATEMENT) | (1L << OBSOLETE_STATEMENT) | (1L << REQUIRED_OBJECT_STATEMENT) | (1L << UNIQUE_OBJECT_STATEMENT) | (1L << COMMENT))) != 0)) {
				{
				State = 89;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case T__0:
				case EXTENSIBLE_STATEMENT:
				case FORMAT_STATEMENT:
				case MEMO_STATEMENT:
				case OBSOLETE_STATEMENT:
				case REQUIRED_OBJECT_STATEMENT:
				case UNIQUE_OBJECT_STATEMENT:
					{
					State = 87; object_property();
					}
					break;
				case COMMENT:
					{
					State = 88; Match(COMMENT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 93;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_propertiesContext : ParserRuleContext {
		public Field_propertyContext[] field_property() {
			return GetRuleContexts<Field_propertyContext>();
		}
		public Field_propertyContext field_property(int i) {
			return GetRuleContext<Field_propertyContext>(i);
		}
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public Field_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_properties; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterField_properties(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitField_properties(this);
		}
	}

	[RuleVersion(0)]
	public Field_propertiesContext field_properties() {
		Field_propertiesContext _localctx = new Field_propertiesContext(Context, State);
		EnterRule(_localctx, 18, RULE_field_properties);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 98;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 96;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case T__1:
					case AUTOCALCULATABLE_STATEMENT:
					case AUTOSIZABLE_STATEMENT:
					case BEGIN_EXTENSIBLE_STATEMENT:
					case DEFAULT_STATEMENT:
					case DEPRECATED_STATEMENT:
					case EXTERNAL_LIST_STATEMENT:
					case FIELD_STATEMENT:
					case IP_UNITS_STATEMENT:
					case KEY_STATEMENT:
					case MAXIMUM_EXCLUSIVE_STATEMENT:
					case MAXIMUM_INCLUSIVE_STATEMENT:
					case MINIMUM_EXCLUSIVE_STATEMENT:
					case MINIMUM_INCLUSIVE_STATEMENT:
					case NOTE_STATEMENT:
					case OBJECT_LIST_STATEMENT:
					case REFERENCE_STATEMENT:
					case REFERENCE_CLASS_NAME_STATEMENT:
					case REQUIRED_FIELD_STATEMENT:
					case RETAINCASE_STATEMENT:
					case TYPE_STATEMENT:
					case UNITS_STATEMENT:
						{
						State = 94; field_property();
						}
						break;
					case COMMENT:
						{
						State = 95; Match(COMMENT);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 100;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_propertyContext : ParserRuleContext {
		public ITerminalNode EXTENSIBLE_STATEMENT() { return GetToken(IddParser.EXTENSIBLE_STATEMENT, 0); }
		public ITerminalNode FORMAT_STATEMENT() { return GetToken(IddParser.FORMAT_STATEMENT, 0); }
		public ITerminalNode MEMO_STATEMENT() { return GetToken(IddParser.MEMO_STATEMENT, 0); }
		public Min_fields_statementContext min_fields_statement() {
			return GetRuleContext<Min_fields_statementContext>(0);
		}
		public ITerminalNode OBSOLETE_STATEMENT() { return GetToken(IddParser.OBSOLETE_STATEMENT, 0); }
		public ITerminalNode REQUIRED_OBJECT_STATEMENT() { return GetToken(IddParser.REQUIRED_OBJECT_STATEMENT, 0); }
		public ITerminalNode UNIQUE_OBJECT_STATEMENT() { return GetToken(IddParser.UNIQUE_OBJECT_STATEMENT, 0); }
		public Object_propertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_property; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterObject_property(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitObject_property(this);
		}
	}

	[RuleVersion(0)]
	public Object_propertyContext object_property() {
		Object_propertyContext _localctx = new Object_propertyContext(Context, State);
		EnterRule(_localctx, 20, RULE_object_property);
		try {
			State = 108;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EXTENSIBLE_STATEMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 101; Match(EXTENSIBLE_STATEMENT);
				}
				break;
			case FORMAT_STATEMENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 102; Match(FORMAT_STATEMENT);
				}
				break;
			case MEMO_STATEMENT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 103; Match(MEMO_STATEMENT);
				}
				break;
			case T__0:
				EnterOuterAlt(_localctx, 4);
				{
				State = 104; min_fields_statement();
				}
				break;
			case OBSOLETE_STATEMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 105; Match(OBSOLETE_STATEMENT);
				}
				break;
			case REQUIRED_OBJECT_STATEMENT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 106; Match(REQUIRED_OBJECT_STATEMENT);
				}
				break;
			case UNIQUE_OBJECT_STATEMENT:
				EnterOuterAlt(_localctx, 7);
				{
				State = 107; Match(UNIQUE_OBJECT_STATEMENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_propertyContext : ParserRuleContext {
		public ITerminalNode AUTOCALCULATABLE_STATEMENT() { return GetToken(IddParser.AUTOCALCULATABLE_STATEMENT, 0); }
		public ITerminalNode AUTOSIZABLE_STATEMENT() { return GetToken(IddParser.AUTOSIZABLE_STATEMENT, 0); }
		public ITerminalNode BEGIN_EXTENSIBLE_STATEMENT() { return GetToken(IddParser.BEGIN_EXTENSIBLE_STATEMENT, 0); }
		public ITerminalNode DEFAULT_STATEMENT() { return GetToken(IddParser.DEFAULT_STATEMENT, 0); }
		public ITerminalNode DEPRECATED_STATEMENT() { return GetToken(IddParser.DEPRECATED_STATEMENT, 0); }
		public ITerminalNode EXTERNAL_LIST_STATEMENT() { return GetToken(IddParser.EXTERNAL_LIST_STATEMENT, 0); }
		public ITerminalNode FIELD_STATEMENT() { return GetToken(IddParser.FIELD_STATEMENT, 0); }
		public ITerminalNode IP_UNITS_STATEMENT() { return GetToken(IddParser.IP_UNITS_STATEMENT, 0); }
		public ITerminalNode KEY_STATEMENT() { return GetToken(IddParser.KEY_STATEMENT, 0); }
		public ITerminalNode MAXIMUM_INCLUSIVE_STATEMENT() { return GetToken(IddParser.MAXIMUM_INCLUSIVE_STATEMENT, 0); }
		public ITerminalNode MAXIMUM_EXCLUSIVE_STATEMENT() { return GetToken(IddParser.MAXIMUM_EXCLUSIVE_STATEMENT, 0); }
		public ITerminalNode MINIMUM_INCLUSIVE_STATEMENT() { return GetToken(IddParser.MINIMUM_INCLUSIVE_STATEMENT, 0); }
		public ITerminalNode MINIMUM_EXCLUSIVE_STATEMENT() { return GetToken(IddParser.MINIMUM_EXCLUSIVE_STATEMENT, 0); }
		public ITerminalNode NOTE_STATEMENT() { return GetToken(IddParser.NOTE_STATEMENT, 0); }
		public ITerminalNode OBJECT_LIST_STATEMENT() { return GetToken(IddParser.OBJECT_LIST_STATEMENT, 0); }
		public ITerminalNode REFERENCE_STATEMENT() { return GetToken(IddParser.REFERENCE_STATEMENT, 0); }
		public ITerminalNode REFERENCE_CLASS_NAME_STATEMENT() { return GetToken(IddParser.REFERENCE_CLASS_NAME_STATEMENT, 0); }
		public ITerminalNode REQUIRED_FIELD_STATEMENT() { return GetToken(IddParser.REQUIRED_FIELD_STATEMENT, 0); }
		public ITerminalNode RETAINCASE_STATEMENT() { return GetToken(IddParser.RETAINCASE_STATEMENT, 0); }
		public ITerminalNode TYPE_STATEMENT() { return GetToken(IddParser.TYPE_STATEMENT, 0); }
		public ITerminalNode UNITS_STATEMENT() { return GetToken(IddParser.UNITS_STATEMENT, 0); }
		public Units_based_on_field_statementContext units_based_on_field_statement() {
			return GetRuleContext<Units_based_on_field_statementContext>(0);
		}
		public Field_propertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_property; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterField_property(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitField_property(this);
		}
	}

	[RuleVersion(0)]
	public Field_propertyContext field_property() {
		Field_propertyContext _localctx = new Field_propertyContext(Context, State);
		EnterRule(_localctx, 22, RULE_field_property);
		try {
			State = 132;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AUTOCALCULATABLE_STATEMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 110; Match(AUTOCALCULATABLE_STATEMENT);
				}
				break;
			case AUTOSIZABLE_STATEMENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 111; Match(AUTOSIZABLE_STATEMENT);
				}
				break;
			case BEGIN_EXTENSIBLE_STATEMENT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 112; Match(BEGIN_EXTENSIBLE_STATEMENT);
				}
				break;
			case DEFAULT_STATEMENT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 113; Match(DEFAULT_STATEMENT);
				}
				break;
			case DEPRECATED_STATEMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 114; Match(DEPRECATED_STATEMENT);
				}
				break;
			case EXTERNAL_LIST_STATEMENT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 115; Match(EXTERNAL_LIST_STATEMENT);
				}
				break;
			case FIELD_STATEMENT:
				EnterOuterAlt(_localctx, 7);
				{
				State = 116; Match(FIELD_STATEMENT);
				}
				break;
			case IP_UNITS_STATEMENT:
				EnterOuterAlt(_localctx, 8);
				{
				State = 117; Match(IP_UNITS_STATEMENT);
				}
				break;
			case KEY_STATEMENT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 118; Match(KEY_STATEMENT);
				}
				break;
			case MAXIMUM_INCLUSIVE_STATEMENT:
				EnterOuterAlt(_localctx, 10);
				{
				State = 119; Match(MAXIMUM_INCLUSIVE_STATEMENT);
				}
				break;
			case MAXIMUM_EXCLUSIVE_STATEMENT:
				EnterOuterAlt(_localctx, 11);
				{
				State = 120; Match(MAXIMUM_EXCLUSIVE_STATEMENT);
				}
				break;
			case MINIMUM_INCLUSIVE_STATEMENT:
				EnterOuterAlt(_localctx, 12);
				{
				State = 121; Match(MINIMUM_INCLUSIVE_STATEMENT);
				}
				break;
			case MINIMUM_EXCLUSIVE_STATEMENT:
				EnterOuterAlt(_localctx, 13);
				{
				State = 122; Match(MINIMUM_EXCLUSIVE_STATEMENT);
				}
				break;
			case NOTE_STATEMENT:
				EnterOuterAlt(_localctx, 14);
				{
				State = 123; Match(NOTE_STATEMENT);
				}
				break;
			case OBJECT_LIST_STATEMENT:
				EnterOuterAlt(_localctx, 15);
				{
				State = 124; Match(OBJECT_LIST_STATEMENT);
				}
				break;
			case REFERENCE_STATEMENT:
				EnterOuterAlt(_localctx, 16);
				{
				State = 125; Match(REFERENCE_STATEMENT);
				}
				break;
			case REFERENCE_CLASS_NAME_STATEMENT:
				EnterOuterAlt(_localctx, 17);
				{
				State = 126; Match(REFERENCE_CLASS_NAME_STATEMENT);
				}
				break;
			case REQUIRED_FIELD_STATEMENT:
				EnterOuterAlt(_localctx, 18);
				{
				State = 127; Match(REQUIRED_FIELD_STATEMENT);
				}
				break;
			case RETAINCASE_STATEMENT:
				EnterOuterAlt(_localctx, 19);
				{
				State = 128; Match(RETAINCASE_STATEMENT);
				}
				break;
			case TYPE_STATEMENT:
				EnterOuterAlt(_localctx, 20);
				{
				State = 129; Match(TYPE_STATEMENT);
				}
				break;
			case UNITS_STATEMENT:
				EnterOuterAlt(_localctx, 21);
				{
				State = 130; Match(UNITS_STATEMENT);
				}
				break;
			case T__1:
				EnterOuterAlt(_localctx, 22);
				{
				State = 131; units_based_on_field_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Min_fields_statementContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(IddParser.INTEGER, 0); }
		public ITerminalNode NEWLINE() { return GetToken(IddParser.NEWLINE, 0); }
		public Min_fields_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_min_fields_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterMin_fields_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitMin_fields_statement(this);
		}
	}

	[RuleVersion(0)]
	public Min_fields_statementContext min_fields_statement() {
		Min_fields_statementContext _localctx = new Min_fields_statementContext(Context, State);
		EnterRule(_localctx, 24, RULE_min_fields_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 134; Match(T__0);
			State = 135; Match(INTEGER);
			State = 136; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Units_based_on_field_statementContext : ParserRuleContext {
		public ITerminalNode NEWLINE() { return GetToken(IddParser.NEWLINE, 0); }
		public ITerminalNode ALPHA_OPTION() { return GetToken(IddParser.ALPHA_OPTION, 0); }
		public ITerminalNode NUMERIC_OPTION() { return GetToken(IddParser.NUMERIC_OPTION, 0); }
		public Units_based_on_field_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_units_based_on_field_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterUnits_based_on_field_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitUnits_based_on_field_statement(this);
		}
	}

	[RuleVersion(0)]
	public Units_based_on_field_statementContext units_based_on_field_statement() {
		Units_based_on_field_statementContext _localctx = new Units_based_on_field_statementContext(Context, State);
		EnterRule(_localctx, 26, RULE_units_based_on_field_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 138; Match(T__1);
			State = 139;
			_la = TokenStream.LA(1);
			if ( !(_la==ALPHA_OPTION || _la==NUMERIC_OPTION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 140; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '*', '\x91', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', 
		'\a', '\x2', '\"', '\n', '\x2', '\f', '\x2', '\xE', '\x2', '%', '\v', 
		'\x2', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x4', '\x3', 
		'\x4', '\x3', '\x4', '\a', '\x4', '-', '\n', '\x4', '\f', '\x4', '\xE', 
		'\x4', '\x30', '\v', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x5', 
		'\a', '\x5', '\x35', '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\x38', '\v', 
		'\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x6', '\x3', '\x6', '\x3', 
		'\x6', '\a', '\x6', '?', '\n', '\x6', '\f', '\x6', '\xE', '\x6', '\x42', 
		'\v', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\a', '\x3', '\a', '\x3', 
		'\a', '\a', '\a', 'I', '\n', '\a', '\f', '\a', '\xE', '\a', 'L', '\v', 
		'\a', '\x3', '\a', '\x3', '\a', '\x3', '\b', '\x3', '\b', '\x3', '\t', 
		'\x3', '\t', '\x3', '\t', '\a', '\t', 'U', '\n', '\t', '\f', '\t', '\xE', 
		'\t', 'X', '\v', '\t', '\x3', '\n', '\x3', '\n', '\a', '\n', '\\', '\n', 
		'\n', '\f', '\n', '\xE', '\n', '_', '\v', '\n', '\x3', '\v', '\x3', '\v', 
		'\a', '\v', '\x63', '\n', '\v', '\f', '\v', '\xE', '\v', '\x66', '\v', 
		'\v', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', 
		'\x3', '\f', '\x3', '\f', '\x5', '\f', 'o', '\n', '\f', '\x3', '\r', '\x3', 
		'\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', 
		'\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', 
		'\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', 
		'\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x5', '\r', '\x87', 
		'\n', '\r', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', 
		'\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x2', 
		'\x2', '\x10', '\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12', 
		'\x14', '\x16', '\x18', '\x1A', '\x1C', '\x2', '\x4', '\x4', '\x2', '&', 
		'&', ')', ')', '\x3', '\x2', '#', '$', '\x2', '\xAA', '\x2', '#', '\x3', 
		'\x2', '\x2', '\x2', '\x4', '&', '\x3', '\x2', '\x2', '\x2', '\x6', ')', 
		'\x3', '\x2', '\x2', '\x2', '\b', '\x36', '\x3', '\x2', '\x2', '\x2', 
		'\n', ';', '\x3', '\x2', '\x2', '\x2', '\f', '\x45', '\x3', '\x2', '\x2', 
		'\x2', '\xE', 'O', '\x3', '\x2', '\x2', '\x2', '\x10', 'Q', '\x3', '\x2', 
		'\x2', '\x2', '\x12', ']', '\x3', '\x2', '\x2', '\x2', '\x14', '\x64', 
		'\x3', '\x2', '\x2', '\x2', '\x16', 'n', '\x3', '\x2', '\x2', '\x2', '\x18', 
		'\x86', '\x3', '\x2', '\x2', '\x2', '\x1A', '\x88', '\x3', '\x2', '\x2', 
		'\x2', '\x1C', '\x8C', '\x3', '\x2', '\x2', '\x2', '\x1E', '\"', '\a', 
		'&', '\x2', '\x2', '\x1F', '\"', '\x5', '\x10', '\t', '\x2', ' ', '\"', 
		'\a', ')', '\x2', '\x2', '!', '\x1E', '\x3', '\x2', '\x2', '\x2', '!', 
		'\x1F', '\x3', '\x2', '\x2', '\x2', '!', ' ', '\x3', '\x2', '\x2', '\x2', 
		'\"', '%', '\x3', '\x2', '\x2', '\x2', '#', '!', '\x3', '\x2', '\x2', 
		'\x2', '#', '$', '\x3', '\x2', '\x2', '\x2', '$', '\x3', '\x3', '\x2', 
		'\x2', '\x2', '%', '#', '\x3', '\x2', '\x2', '\x2', '&', '\'', '\x5', 
		'\x6', '\x4', '\x2', '\'', '(', '\x5', '\b', '\x5', '\x2', '(', '\x5', 
		'\x3', '\x2', '\x2', '\x2', ')', '*', '\a', '%', '\x2', '\x2', '*', '.', 
		'\a', '\'', '\x2', '\x2', '+', '-', '\t', '\x2', '\x2', '\x2', ',', '+', 
		'\x3', '\x2', '\x2', '\x2', '-', '\x30', '\x3', '\x2', '\x2', '\x2', '.', 
		',', '\x3', '\x2', '\x2', '\x2', '.', '/', '\x3', '\x2', '\x2', '\x2', 
		'/', '\x31', '\x3', '\x2', '\x2', '\x2', '\x30', '.', '\x3', '\x2', '\x2', 
		'\x2', '\x31', '\x32', '\x5', '\x12', '\n', '\x2', '\x32', '\a', '\x3', 
		'\x2', '\x2', '\x2', '\x33', '\x35', '\x5', '\f', '\a', '\x2', '\x34', 
		'\x33', '\x3', '\x2', '\x2', '\x2', '\x35', '\x38', '\x3', '\x2', '\x2', 
		'\x2', '\x36', '\x34', '\x3', '\x2', '\x2', '\x2', '\x36', '\x37', '\x3', 
		'\x2', '\x2', '\x2', '\x37', '\x39', '\x3', '\x2', '\x2', '\x2', '\x38', 
		'\x36', '\x3', '\x2', '\x2', '\x2', '\x39', ':', '\x5', '\n', '\x6', '\x2', 
		':', '\t', '\x3', '\x2', '\x2', '\x2', ';', '<', '\x5', '\xE', '\b', '\x2', 
		'<', '@', '\a', '(', '\x2', '\x2', '=', '?', '\a', ')', '\x2', '\x2', 
		'>', '=', '\x3', '\x2', '\x2', '\x2', '?', '\x42', '\x3', '\x2', '\x2', 
		'\x2', '@', '>', '\x3', '\x2', '\x2', '\x2', '@', '\x41', '\x3', '\x2', 
		'\x2', '\x2', '\x41', '\x43', '\x3', '\x2', '\x2', '\x2', '\x42', '@', 
		'\x3', '\x2', '\x2', '\x2', '\x43', '\x44', '\x5', '\x14', '\v', '\x2', 
		'\x44', '\v', '\x3', '\x2', '\x2', '\x2', '\x45', '\x46', '\x5', '\xE', 
		'\b', '\x2', '\x46', 'J', '\a', '\'', '\x2', '\x2', 'G', 'I', '\a', ')', 
		'\x2', '\x2', 'H', 'G', '\x3', '\x2', '\x2', '\x2', 'I', 'L', '\x3', '\x2', 
		'\x2', '\x2', 'J', 'H', '\x3', '\x2', '\x2', '\x2', 'J', 'K', '\x3', '\x2', 
		'\x2', '\x2', 'K', 'M', '\x3', '\x2', '\x2', '\x2', 'L', 'J', '\x3', '\x2', 
		'\x2', '\x2', 'M', 'N', '\x5', '\x14', '\v', '\x2', 'N', '\r', '\x3', 
		'\x2', '\x2', '\x2', 'O', 'P', '\t', '\x3', '\x2', '\x2', 'P', '\xF', 
		'\x3', '\x2', '\x2', '\x2', 'Q', 'V', '\a', '\x5', '\x2', '\x2', 'R', 
		'U', '\x5', '\x4', '\x3', '\x2', 'S', 'U', '\a', '&', '\x2', '\x2', 'T', 
		'R', '\x3', '\x2', '\x2', '\x2', 'T', 'S', '\x3', '\x2', '\x2', '\x2', 
		'U', 'X', '\x3', '\x2', '\x2', '\x2', 'V', 'T', '\x3', '\x2', '\x2', '\x2', 
		'V', 'W', '\x3', '\x2', '\x2', '\x2', 'W', '\x11', '\x3', '\x2', '\x2', 
		'\x2', 'X', 'V', '\x3', '\x2', '\x2', '\x2', 'Y', '\\', '\x5', '\x16', 
		'\f', '\x2', 'Z', '\\', '\a', '&', '\x2', '\x2', '[', 'Y', '\x3', '\x2', 
		'\x2', '\x2', '[', 'Z', '\x3', '\x2', '\x2', '\x2', '\\', '_', '\x3', 
		'\x2', '\x2', '\x2', ']', '[', '\x3', '\x2', '\x2', '\x2', ']', '^', '\x3', 
		'\x2', '\x2', '\x2', '^', '\x13', '\x3', '\x2', '\x2', '\x2', '_', ']', 
		'\x3', '\x2', '\x2', '\x2', '`', '\x63', '\x5', '\x18', '\r', '\x2', '\x61', 
		'\x63', '\a', '&', '\x2', '\x2', '\x62', '`', '\x3', '\x2', '\x2', '\x2', 
		'\x62', '\x61', '\x3', '\x2', '\x2', '\x2', '\x63', '\x66', '\x3', '\x2', 
		'\x2', '\x2', '\x64', '\x62', '\x3', '\x2', '\x2', '\x2', '\x64', '\x65', 
		'\x3', '\x2', '\x2', '\x2', '\x65', '\x15', '\x3', '\x2', '\x2', '\x2', 
		'\x66', '\x64', '\x3', '\x2', '\x2', '\x2', 'g', 'o', '\a', '\v', '\x2', 
		'\x2', 'h', 'o', '\a', '\xE', '\x2', '\x2', 'i', 'o', '\a', '\x14', '\x2', 
		'\x2', 'j', 'o', '\x5', '\x1A', '\xE', '\x2', 'k', 'o', '\a', '\x19', 
		'\x2', '\x2', 'l', 'o', '\a', '\x1D', '\x2', '\x2', 'm', 'o', '\a', ' ', 
		'\x2', '\x2', 'n', 'g', '\x3', '\x2', '\x2', '\x2', 'n', 'h', '\x3', '\x2', 
		'\x2', '\x2', 'n', 'i', '\x3', '\x2', '\x2', '\x2', 'n', 'j', '\x3', '\x2', 
		'\x2', '\x2', 'n', 'k', '\x3', '\x2', '\x2', '\x2', 'n', 'l', '\x3', '\x2', 
		'\x2', '\x2', 'n', 'm', '\x3', '\x2', '\x2', '\x2', 'o', '\x17', '\x3', 
		'\x2', '\x2', '\x2', 'p', '\x87', '\a', '\x6', '\x2', '\x2', 'q', '\x87', 
		'\a', '\a', '\x2', '\x2', 'r', '\x87', '\a', '\b', '\x2', '\x2', 's', 
		'\x87', '\a', '\t', '\x2', '\x2', 't', '\x87', '\a', '\n', '\x2', '\x2', 
		'u', '\x87', '\a', '\f', '\x2', '\x2', 'v', '\x87', '\a', '\r', '\x2', 
		'\x2', 'w', '\x87', '\a', '\x10', '\x2', '\x2', 'x', '\x87', '\a', '\x11', 
		'\x2', '\x2', 'y', '\x87', '\a', '\x13', '\x2', '\x2', 'z', '\x87', '\a', 
		'\x12', '\x2', '\x2', '{', '\x87', '\a', '\x16', '\x2', '\x2', '|', '\x87', 
		'\a', '\x15', '\x2', '\x2', '}', '\x87', '\a', '\x17', '\x2', '\x2', '~', 
		'\x87', '\a', '\x18', '\x2', '\x2', '\x7F', '\x87', '\a', '\x1A', '\x2', 
		'\x2', '\x80', '\x87', '\a', '\x1B', '\x2', '\x2', '\x81', '\x87', '\a', 
		'\x1C', '\x2', '\x2', '\x82', '\x87', '\a', '\x1E', '\x2', '\x2', '\x83', 
		'\x87', '\a', '\x1F', '\x2', '\x2', '\x84', '\x87', '\a', '!', '\x2', 
		'\x2', '\x85', '\x87', '\x5', '\x1C', '\xF', '\x2', '\x86', 'p', '\x3', 
		'\x2', '\x2', '\x2', '\x86', 'q', '\x3', '\x2', '\x2', '\x2', '\x86', 
		'r', '\x3', '\x2', '\x2', '\x2', '\x86', 's', '\x3', '\x2', '\x2', '\x2', 
		'\x86', 't', '\x3', '\x2', '\x2', '\x2', '\x86', 'u', '\x3', '\x2', '\x2', 
		'\x2', '\x86', 'v', '\x3', '\x2', '\x2', '\x2', '\x86', 'w', '\x3', '\x2', 
		'\x2', '\x2', '\x86', 'x', '\x3', '\x2', '\x2', '\x2', '\x86', 'y', '\x3', 
		'\x2', '\x2', '\x2', '\x86', 'z', '\x3', '\x2', '\x2', '\x2', '\x86', 
		'{', '\x3', '\x2', '\x2', '\x2', '\x86', '|', '\x3', '\x2', '\x2', '\x2', 
		'\x86', '}', '\x3', '\x2', '\x2', '\x2', '\x86', '~', '\x3', '\x2', '\x2', 
		'\x2', '\x86', '\x7F', '\x3', '\x2', '\x2', '\x2', '\x86', '\x80', '\x3', 
		'\x2', '\x2', '\x2', '\x86', '\x81', '\x3', '\x2', '\x2', '\x2', '\x86', 
		'\x82', '\x3', '\x2', '\x2', '\x2', '\x86', '\x83', '\x3', '\x2', '\x2', 
		'\x2', '\x86', '\x84', '\x3', '\x2', '\x2', '\x2', '\x86', '\x85', '\x3', 
		'\x2', '\x2', '\x2', '\x87', '\x19', '\x3', '\x2', '\x2', '\x2', '\x88', 
		'\x89', '\a', '\x3', '\x2', '\x2', '\x89', '\x8A', '\a', '\"', '\x2', 
		'\x2', '\x8A', '\x8B', '\a', ')', '\x2', '\x2', '\x8B', '\x1B', '\x3', 
		'\x2', '\x2', '\x2', '\x8C', '\x8D', '\a', '\x4', '\x2', '\x2', '\x8D', 
		'\x8E', '\t', '\x3', '\x2', '\x2', '\x8E', '\x8F', '\a', ')', '\x2', '\x2', 
		'\x8F', '\x1D', '\x3', '\x2', '\x2', '\x2', '\x10', '!', '#', '.', '\x36', 
		'@', 'J', 'T', 'V', '[', ']', '\x62', '\x64', 'n', '\x86',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
