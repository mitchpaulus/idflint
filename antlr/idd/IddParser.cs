//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from Idd.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
[System.CLSCompliant(false)]
public partial class IddParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, FIELD_TYPE=8, 
		AUTOCALCULATABLE_STATEMENT=9, AUTOSIZABLE_STATEMENT=10, BEGIN_EXTENSIBLE_STATEMENT=11, 
		DEFAULT_STATEMENT=12, DEPRECATED_STATEMENT=13, EXTENSIBLE_STATEMENT=14, 
		EXTERNAL_LIST_STATEMENT=15, FIELD_STATEMENT=16, FORMAT_STATEMENT=17, GROUP_STATEMENT=18, 
		IP_UNITS_STATEMENT=19, KEY_STATEMENT=20, MEMO_STATEMENT=21, NOTE_STATEMENT=22, 
		OBJECT_LIST_STATEMENT=23, OBSOLETE_STATEMENT=24, REFERENCE_STATEMENT=25, 
		REFERENCE_CLASS_NAME_STATEMENT=26, REQUIRED_FIELD_STATEMENT=27, REQUIRED_OBJECT_STATEMENT=28, 
		RETAINCASE_STATEMENT=29, UNIQUE_OBJECT_STATEMENT=30, UNITS_STATEMENT=31, 
		INTEGER=32, REALNUMBER=33, ALPHA_OPTION=34, NUMERIC_OPTION=35, OBJECT_NAME=36, 
		COMMENT=37, FIELD_SEPARATOR=38, OBJECT_TERMINATOR=39, NEWLINE=40, WS=41;
	public const int
		RULE_idd = 0, RULE_object = 1, RULE_object_header = 2, RULE_fields = 3, 
		RULE_terminating_field = 4, RULE_field = 5, RULE_field_id = 6, RULE_group = 7, 
		RULE_object_properties = 8, RULE_field_properties = 9, RULE_object_property = 10, 
		RULE_field_property = 11, RULE_maximum_exclusive_statement = 12, RULE_maximum_inclusive_statement = 13, 
		RULE_min_fields_statement = 14, RULE_minimum_exclusive_statement = 15, 
		RULE_minimum_inclusive_statement = 16, RULE_type_statement = 17, RULE_units_based_on_field_statement = 18;
	public static readonly string[] ruleNames = {
		"idd", "object", "object_header", "fields", "terminating_field", "field", 
		"field_id", "group", "object_properties", "field_properties", "object_property", 
		"field_property", "maximum_exclusive_statement", "maximum_inclusive_statement", 
		"min_fields_statement", "minimum_exclusive_statement", "minimum_inclusive_statement", 
		"type_statement", "units_based_on_field_statement"
	};

	private static readonly string[] _LiteralNames = {
		null, "'\\maximum< '", "'\\maximum '", "'\\min-fields '", "'\\minimum>'", 
		"'\\minimum '", "'\\type '", "'\\unitsBasedOnField '", null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, "','", "';'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, "FIELD_TYPE", "AUTOCALCULATABLE_STATEMENT", 
		"AUTOSIZABLE_STATEMENT", "BEGIN_EXTENSIBLE_STATEMENT", "DEFAULT_STATEMENT", 
		"DEPRECATED_STATEMENT", "EXTENSIBLE_STATEMENT", "EXTERNAL_LIST_STATEMENT", 
		"FIELD_STATEMENT", "FORMAT_STATEMENT", "GROUP_STATEMENT", "IP_UNITS_STATEMENT", 
		"KEY_STATEMENT", "MEMO_STATEMENT", "NOTE_STATEMENT", "OBJECT_LIST_STATEMENT", 
		"OBSOLETE_STATEMENT", "REFERENCE_STATEMENT", "REFERENCE_CLASS_NAME_STATEMENT", 
		"REQUIRED_FIELD_STATEMENT", "REQUIRED_OBJECT_STATEMENT", "RETAINCASE_STATEMENT", 
		"UNIQUE_OBJECT_STATEMENT", "UNITS_STATEMENT", "INTEGER", "REALNUMBER", 
		"ALPHA_OPTION", "NUMERIC_OPTION", "OBJECT_NAME", "COMMENT", "FIELD_SEPARATOR", 
		"OBJECT_TERMINATOR", "NEWLINE", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Idd.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static IddParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public IddParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public IddParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class IddContext : ParserRuleContext {
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public GroupContext[] group() {
			return GetRuleContexts<GroupContext>();
		}
		public GroupContext group(int i) {
			return GetRuleContext<GroupContext>(i);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(IddParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(IddParser.NEWLINE, i);
		}
		public IddContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_idd; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterIdd(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitIdd(this);
		}
	}

	[RuleVersion(0)]
	public IddContext idd() {
		IddContext _localctx = new IddContext(Context, State);
		EnterRule(_localctx, 0, RULE_idd);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 43;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << GROUP_STATEMENT) | (1L << COMMENT) | (1L << NEWLINE))) != 0)) {
				{
				State = 41;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case COMMENT:
					{
					State = 38; Match(COMMENT);
					}
					break;
				case GROUP_STATEMENT:
					{
					State = 39; group();
					}
					break;
				case NEWLINE:
					{
					State = 40; Match(NEWLINE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 45;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectContext : ParserRuleContext {
		public Object_headerContext object_header() {
			return GetRuleContext<Object_headerContext>(0);
		}
		public FieldsContext fields() {
			return GetRuleContext<FieldsContext>(0);
		}
		public ObjectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterObject(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitObject(this);
		}
	}

	[RuleVersion(0)]
	public ObjectContext @object() {
		ObjectContext _localctx = new ObjectContext(Context, State);
		EnterRule(_localctx, 2, RULE_object);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 46; object_header();
			State = 47; fields();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_headerContext : ParserRuleContext {
		public ITerminalNode OBJECT_NAME() { return GetToken(IddParser.OBJECT_NAME, 0); }
		public ITerminalNode FIELD_SEPARATOR() { return GetToken(IddParser.FIELD_SEPARATOR, 0); }
		public Object_propertiesContext object_properties() {
			return GetRuleContext<Object_propertiesContext>(0);
		}
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(IddParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(IddParser.NEWLINE, i);
		}
		public Object_headerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_header; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterObject_header(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitObject_header(this);
		}
	}

	[RuleVersion(0)]
	public Object_headerContext object_header() {
		Object_headerContext _localctx = new Object_headerContext(Context, State);
		EnterRule(_localctx, 4, RULE_object_header);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 49; Match(OBJECT_NAME);
			State = 50; Match(FIELD_SEPARATOR);
			State = 54;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 51;
					_la = TokenStream.LA(1);
					if ( !(_la==COMMENT || _la==NEWLINE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					} 
				}
				State = 56;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			}
			State = 57; object_properties();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldsContext : ParserRuleContext {
		public Terminating_fieldContext terminating_field() {
			return GetRuleContext<Terminating_fieldContext>(0);
		}
		public FieldContext[] field() {
			return GetRuleContexts<FieldContext>();
		}
		public FieldContext field(int i) {
			return GetRuleContext<FieldContext>(i);
		}
		public FieldsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fields; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterFields(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitFields(this);
		}
	}

	[RuleVersion(0)]
	public FieldsContext fields() {
		FieldsContext _localctx = new FieldsContext(Context, State);
		EnterRule(_localctx, 6, RULE_fields);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 62;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 59; field();
					}
					} 
				}
				State = 64;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			}
			State = 65; terminating_field();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Terminating_fieldContext : ParserRuleContext {
		public Field_idContext field_id() {
			return GetRuleContext<Field_idContext>(0);
		}
		public ITerminalNode OBJECT_TERMINATOR() { return GetToken(IddParser.OBJECT_TERMINATOR, 0); }
		public Field_propertiesContext field_properties() {
			return GetRuleContext<Field_propertiesContext>(0);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(IddParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(IddParser.NEWLINE, i);
		}
		public Terminating_fieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_terminating_field; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterTerminating_field(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitTerminating_field(this);
		}
	}

	[RuleVersion(0)]
	public Terminating_fieldContext terminating_field() {
		Terminating_fieldContext _localctx = new Terminating_fieldContext(Context, State);
		EnterRule(_localctx, 8, RULE_terminating_field);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 67; field_id();
			State = 68; Match(OBJECT_TERMINATOR);
			State = 72;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,4,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 69; Match(NEWLINE);
					}
					} 
				}
				State = 74;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,4,Context);
			}
			State = 75; field_properties();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldContext : ParserRuleContext {
		public Field_idContext field_id() {
			return GetRuleContext<Field_idContext>(0);
		}
		public ITerminalNode FIELD_SEPARATOR() { return GetToken(IddParser.FIELD_SEPARATOR, 0); }
		public Field_propertiesContext field_properties() {
			return GetRuleContext<Field_propertiesContext>(0);
		}
		public ITerminalNode[] NEWLINE() { return GetTokens(IddParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(IddParser.NEWLINE, i);
		}
		public FieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitField(this);
		}
	}

	[RuleVersion(0)]
	public FieldContext field() {
		FieldContext _localctx = new FieldContext(Context, State);
		EnterRule(_localctx, 10, RULE_field);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77; field_id();
			State = 78; Match(FIELD_SEPARATOR);
			State = 82;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==NEWLINE) {
				{
				{
				State = 79; Match(NEWLINE);
				}
				}
				State = 84;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 85; field_properties();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_idContext : ParserRuleContext {
		public ITerminalNode ALPHA_OPTION() { return GetToken(IddParser.ALPHA_OPTION, 0); }
		public ITerminalNode NUMERIC_OPTION() { return GetToken(IddParser.NUMERIC_OPTION, 0); }
		public Field_idContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_id; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterField_id(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitField_id(this);
		}
	}

	[RuleVersion(0)]
	public Field_idContext field_id() {
		Field_idContext _localctx = new Field_idContext(Context, State);
		EnterRule(_localctx, 12, RULE_field_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 87;
			_la = TokenStream.LA(1);
			if ( !(_la==ALPHA_OPTION || _la==NUMERIC_OPTION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupContext : ParserRuleContext {
		public ITerminalNode GROUP_STATEMENT() { return GetToken(IddParser.GROUP_STATEMENT, 0); }
		public ObjectContext[] @object() {
			return GetRuleContexts<ObjectContext>();
		}
		public ObjectContext @object(int i) {
			return GetRuleContext<ObjectContext>(i);
		}
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public GroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitGroup(this);
		}
	}

	[RuleVersion(0)]
	public GroupContext group() {
		GroupContext _localctx = new GroupContext(Context, State);
		EnterRule(_localctx, 14, RULE_group);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 89; Match(GROUP_STATEMENT);
			State = 94;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 92;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case OBJECT_NAME:
						{
						State = 90; @object();
						}
						break;
					case COMMENT:
						{
						State = 91; Match(COMMENT);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 96;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_propertiesContext : ParserRuleContext {
		public Object_propertyContext[] object_property() {
			return GetRuleContexts<Object_propertyContext>();
		}
		public Object_propertyContext object_property(int i) {
			return GetRuleContext<Object_propertyContext>(i);
		}
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public Object_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_properties; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterObject_properties(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitObject_properties(this);
		}
	}

	[RuleVersion(0)]
	public Object_propertiesContext object_properties() {
		Object_propertiesContext _localctx = new Object_propertiesContext(Context, State);
		EnterRule(_localctx, 16, RULE_object_properties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 101;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__2) | (1L << EXTENSIBLE_STATEMENT) | (1L << FORMAT_STATEMENT) | (1L << MEMO_STATEMENT) | (1L << OBSOLETE_STATEMENT) | (1L << REQUIRED_OBJECT_STATEMENT) | (1L << UNIQUE_OBJECT_STATEMENT) | (1L << COMMENT))) != 0)) {
				{
				State = 99;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case T__2:
				case EXTENSIBLE_STATEMENT:
				case FORMAT_STATEMENT:
				case MEMO_STATEMENT:
				case OBSOLETE_STATEMENT:
				case REQUIRED_OBJECT_STATEMENT:
				case UNIQUE_OBJECT_STATEMENT:
					{
					State = 97; object_property();
					}
					break;
				case COMMENT:
					{
					State = 98; Match(COMMENT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 103;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_propertiesContext : ParserRuleContext {
		public Field_propertyContext[] field_property() {
			return GetRuleContexts<Field_propertyContext>();
		}
		public Field_propertyContext field_property(int i) {
			return GetRuleContext<Field_propertyContext>(i);
		}
		public ITerminalNode[] COMMENT() { return GetTokens(IddParser.COMMENT); }
		public ITerminalNode COMMENT(int i) {
			return GetToken(IddParser.COMMENT, i);
		}
		public Field_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_properties; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterField_properties(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitField_properties(this);
		}
	}

	[RuleVersion(0)]
	public Field_propertiesContext field_properties() {
		Field_propertiesContext _localctx = new Field_propertiesContext(Context, State);
		EnterRule(_localctx, 18, RULE_field_properties);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 108;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 106;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case T__0:
					case T__1:
					case T__3:
					case T__4:
					case T__5:
					case T__6:
					case AUTOCALCULATABLE_STATEMENT:
					case AUTOSIZABLE_STATEMENT:
					case BEGIN_EXTENSIBLE_STATEMENT:
					case DEFAULT_STATEMENT:
					case DEPRECATED_STATEMENT:
					case EXTERNAL_LIST_STATEMENT:
					case FIELD_STATEMENT:
					case IP_UNITS_STATEMENT:
					case KEY_STATEMENT:
					case NOTE_STATEMENT:
					case OBJECT_LIST_STATEMENT:
					case REFERENCE_STATEMENT:
					case REFERENCE_CLASS_NAME_STATEMENT:
					case REQUIRED_FIELD_STATEMENT:
					case RETAINCASE_STATEMENT:
					case UNITS_STATEMENT:
						{
						State = 104; field_property();
						}
						break;
					case COMMENT:
						{
						State = 105; Match(COMMENT);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 110;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_propertyContext : ParserRuleContext {
		public ITerminalNode EXTENSIBLE_STATEMENT() { return GetToken(IddParser.EXTENSIBLE_STATEMENT, 0); }
		public ITerminalNode FORMAT_STATEMENT() { return GetToken(IddParser.FORMAT_STATEMENT, 0); }
		public ITerminalNode MEMO_STATEMENT() { return GetToken(IddParser.MEMO_STATEMENT, 0); }
		public Min_fields_statementContext min_fields_statement() {
			return GetRuleContext<Min_fields_statementContext>(0);
		}
		public ITerminalNode OBSOLETE_STATEMENT() { return GetToken(IddParser.OBSOLETE_STATEMENT, 0); }
		public ITerminalNode REQUIRED_OBJECT_STATEMENT() { return GetToken(IddParser.REQUIRED_OBJECT_STATEMENT, 0); }
		public ITerminalNode UNIQUE_OBJECT_STATEMENT() { return GetToken(IddParser.UNIQUE_OBJECT_STATEMENT, 0); }
		public Object_propertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_property; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterObject_property(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitObject_property(this);
		}
	}

	[RuleVersion(0)]
	public Object_propertyContext object_property() {
		Object_propertyContext _localctx = new Object_propertyContext(Context, State);
		EnterRule(_localctx, 20, RULE_object_property);
		try {
			State = 118;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EXTENSIBLE_STATEMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 111; Match(EXTENSIBLE_STATEMENT);
				}
				break;
			case FORMAT_STATEMENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 112; Match(FORMAT_STATEMENT);
				}
				break;
			case MEMO_STATEMENT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 113; Match(MEMO_STATEMENT);
				}
				break;
			case T__2:
				EnterOuterAlt(_localctx, 4);
				{
				State = 114; min_fields_statement();
				}
				break;
			case OBSOLETE_STATEMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 115; Match(OBSOLETE_STATEMENT);
				}
				break;
			case REQUIRED_OBJECT_STATEMENT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 116; Match(REQUIRED_OBJECT_STATEMENT);
				}
				break;
			case UNIQUE_OBJECT_STATEMENT:
				EnterOuterAlt(_localctx, 7);
				{
				State = 117; Match(UNIQUE_OBJECT_STATEMENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_propertyContext : ParserRuleContext {
		public ITerminalNode AUTOCALCULATABLE_STATEMENT() { return GetToken(IddParser.AUTOCALCULATABLE_STATEMENT, 0); }
		public ITerminalNode AUTOSIZABLE_STATEMENT() { return GetToken(IddParser.AUTOSIZABLE_STATEMENT, 0); }
		public ITerminalNode BEGIN_EXTENSIBLE_STATEMENT() { return GetToken(IddParser.BEGIN_EXTENSIBLE_STATEMENT, 0); }
		public ITerminalNode DEFAULT_STATEMENT() { return GetToken(IddParser.DEFAULT_STATEMENT, 0); }
		public ITerminalNode DEPRECATED_STATEMENT() { return GetToken(IddParser.DEPRECATED_STATEMENT, 0); }
		public ITerminalNode EXTERNAL_LIST_STATEMENT() { return GetToken(IddParser.EXTERNAL_LIST_STATEMENT, 0); }
		public ITerminalNode FIELD_STATEMENT() { return GetToken(IddParser.FIELD_STATEMENT, 0); }
		public ITerminalNode IP_UNITS_STATEMENT() { return GetToken(IddParser.IP_UNITS_STATEMENT, 0); }
		public ITerminalNode KEY_STATEMENT() { return GetToken(IddParser.KEY_STATEMENT, 0); }
		public Maximum_inclusive_statementContext maximum_inclusive_statement() {
			return GetRuleContext<Maximum_inclusive_statementContext>(0);
		}
		public Maximum_exclusive_statementContext maximum_exclusive_statement() {
			return GetRuleContext<Maximum_exclusive_statementContext>(0);
		}
		public Minimum_inclusive_statementContext minimum_inclusive_statement() {
			return GetRuleContext<Minimum_inclusive_statementContext>(0);
		}
		public Minimum_exclusive_statementContext minimum_exclusive_statement() {
			return GetRuleContext<Minimum_exclusive_statementContext>(0);
		}
		public ITerminalNode NOTE_STATEMENT() { return GetToken(IddParser.NOTE_STATEMENT, 0); }
		public ITerminalNode OBJECT_LIST_STATEMENT() { return GetToken(IddParser.OBJECT_LIST_STATEMENT, 0); }
		public ITerminalNode REFERENCE_STATEMENT() { return GetToken(IddParser.REFERENCE_STATEMENT, 0); }
		public ITerminalNode REFERENCE_CLASS_NAME_STATEMENT() { return GetToken(IddParser.REFERENCE_CLASS_NAME_STATEMENT, 0); }
		public ITerminalNode REQUIRED_FIELD_STATEMENT() { return GetToken(IddParser.REQUIRED_FIELD_STATEMENT, 0); }
		public ITerminalNode RETAINCASE_STATEMENT() { return GetToken(IddParser.RETAINCASE_STATEMENT, 0); }
		public Type_statementContext type_statement() {
			return GetRuleContext<Type_statementContext>(0);
		}
		public ITerminalNode UNITS_STATEMENT() { return GetToken(IddParser.UNITS_STATEMENT, 0); }
		public Units_based_on_field_statementContext units_based_on_field_statement() {
			return GetRuleContext<Units_based_on_field_statementContext>(0);
		}
		public Field_propertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_property; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterField_property(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitField_property(this);
		}
	}

	[RuleVersion(0)]
	public Field_propertyContext field_property() {
		Field_propertyContext _localctx = new Field_propertyContext(Context, State);
		EnterRule(_localctx, 22, RULE_field_property);
		try {
			State = 142;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AUTOCALCULATABLE_STATEMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 120; Match(AUTOCALCULATABLE_STATEMENT);
				}
				break;
			case AUTOSIZABLE_STATEMENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 121; Match(AUTOSIZABLE_STATEMENT);
				}
				break;
			case BEGIN_EXTENSIBLE_STATEMENT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 122; Match(BEGIN_EXTENSIBLE_STATEMENT);
				}
				break;
			case DEFAULT_STATEMENT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 123; Match(DEFAULT_STATEMENT);
				}
				break;
			case DEPRECATED_STATEMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 124; Match(DEPRECATED_STATEMENT);
				}
				break;
			case EXTERNAL_LIST_STATEMENT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 125; Match(EXTERNAL_LIST_STATEMENT);
				}
				break;
			case FIELD_STATEMENT:
				EnterOuterAlt(_localctx, 7);
				{
				State = 126; Match(FIELD_STATEMENT);
				}
				break;
			case IP_UNITS_STATEMENT:
				EnterOuterAlt(_localctx, 8);
				{
				State = 127; Match(IP_UNITS_STATEMENT);
				}
				break;
			case KEY_STATEMENT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 128; Match(KEY_STATEMENT);
				}
				break;
			case T__1:
				EnterOuterAlt(_localctx, 10);
				{
				State = 129; maximum_inclusive_statement();
				}
				break;
			case T__0:
				EnterOuterAlt(_localctx, 11);
				{
				State = 130; maximum_exclusive_statement();
				}
				break;
			case T__4:
				EnterOuterAlt(_localctx, 12);
				{
				State = 131; minimum_inclusive_statement();
				}
				break;
			case T__3:
				EnterOuterAlt(_localctx, 13);
				{
				State = 132; minimum_exclusive_statement();
				}
				break;
			case NOTE_STATEMENT:
				EnterOuterAlt(_localctx, 14);
				{
				State = 133; Match(NOTE_STATEMENT);
				}
				break;
			case OBJECT_LIST_STATEMENT:
				EnterOuterAlt(_localctx, 15);
				{
				State = 134; Match(OBJECT_LIST_STATEMENT);
				}
				break;
			case REFERENCE_STATEMENT:
				EnterOuterAlt(_localctx, 16);
				{
				State = 135; Match(REFERENCE_STATEMENT);
				}
				break;
			case REFERENCE_CLASS_NAME_STATEMENT:
				EnterOuterAlt(_localctx, 17);
				{
				State = 136; Match(REFERENCE_CLASS_NAME_STATEMENT);
				}
				break;
			case REQUIRED_FIELD_STATEMENT:
				EnterOuterAlt(_localctx, 18);
				{
				State = 137; Match(REQUIRED_FIELD_STATEMENT);
				}
				break;
			case RETAINCASE_STATEMENT:
				EnterOuterAlt(_localctx, 19);
				{
				State = 138; Match(RETAINCASE_STATEMENT);
				}
				break;
			case T__5:
				EnterOuterAlt(_localctx, 20);
				{
				State = 139; type_statement();
				}
				break;
			case UNITS_STATEMENT:
				EnterOuterAlt(_localctx, 21);
				{
				State = 140; Match(UNITS_STATEMENT);
				}
				break;
			case T__6:
				EnterOuterAlt(_localctx, 22);
				{
				State = 141; units_based_on_field_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Maximum_exclusive_statementContext : ParserRuleContext {
		public IToken maxval;
		public ITerminalNode NEWLINE() { return GetToken(IddParser.NEWLINE, 0); }
		public ITerminalNode REALNUMBER() { return GetToken(IddParser.REALNUMBER, 0); }
		public ITerminalNode INTEGER() { return GetToken(IddParser.INTEGER, 0); }
		public Maximum_exclusive_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maximum_exclusive_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterMaximum_exclusive_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitMaximum_exclusive_statement(this);
		}
	}

	[RuleVersion(0)]
	public Maximum_exclusive_statementContext maximum_exclusive_statement() {
		Maximum_exclusive_statementContext _localctx = new Maximum_exclusive_statementContext(Context, State);
		EnterRule(_localctx, 24, RULE_maximum_exclusive_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144; Match(T__0);
			State = 145;
			_localctx.maxval = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==INTEGER || _la==REALNUMBER) ) {
				_localctx.maxval = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 146; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Maximum_inclusive_statementContext : ParserRuleContext {
		public IToken maxval;
		public ITerminalNode NEWLINE() { return GetToken(IddParser.NEWLINE, 0); }
		public ITerminalNode REALNUMBER() { return GetToken(IddParser.REALNUMBER, 0); }
		public ITerminalNode INTEGER() { return GetToken(IddParser.INTEGER, 0); }
		public Maximum_inclusive_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maximum_inclusive_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterMaximum_inclusive_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitMaximum_inclusive_statement(this);
		}
	}

	[RuleVersion(0)]
	public Maximum_inclusive_statementContext maximum_inclusive_statement() {
		Maximum_inclusive_statementContext _localctx = new Maximum_inclusive_statementContext(Context, State);
		EnterRule(_localctx, 26, RULE_maximum_inclusive_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 148; Match(T__1);
			State = 149;
			_localctx.maxval = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==INTEGER || _la==REALNUMBER) ) {
				_localctx.maxval = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 150; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Min_fields_statementContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(IddParser.INTEGER, 0); }
		public ITerminalNode NEWLINE() { return GetToken(IddParser.NEWLINE, 0); }
		public Min_fields_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_min_fields_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterMin_fields_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitMin_fields_statement(this);
		}
	}

	[RuleVersion(0)]
	public Min_fields_statementContext min_fields_statement() {
		Min_fields_statementContext _localctx = new Min_fields_statementContext(Context, State);
		EnterRule(_localctx, 28, RULE_min_fields_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 152; Match(T__2);
			State = 153; Match(INTEGER);
			State = 154; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Minimum_exclusive_statementContext : ParserRuleContext {
		public IToken minval;
		public ITerminalNode NEWLINE() { return GetToken(IddParser.NEWLINE, 0); }
		public ITerminalNode REALNUMBER() { return GetToken(IddParser.REALNUMBER, 0); }
		public ITerminalNode INTEGER() { return GetToken(IddParser.INTEGER, 0); }
		public Minimum_exclusive_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_minimum_exclusive_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterMinimum_exclusive_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitMinimum_exclusive_statement(this);
		}
	}

	[RuleVersion(0)]
	public Minimum_exclusive_statementContext minimum_exclusive_statement() {
		Minimum_exclusive_statementContext _localctx = new Minimum_exclusive_statementContext(Context, State);
		EnterRule(_localctx, 30, RULE_minimum_exclusive_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 156; Match(T__3);
			State = 157;
			_localctx.minval = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==INTEGER || _la==REALNUMBER) ) {
				_localctx.minval = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 158; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Minimum_inclusive_statementContext : ParserRuleContext {
		public IToken minval;
		public ITerminalNode NEWLINE() { return GetToken(IddParser.NEWLINE, 0); }
		public ITerminalNode REALNUMBER() { return GetToken(IddParser.REALNUMBER, 0); }
		public ITerminalNode INTEGER() { return GetToken(IddParser.INTEGER, 0); }
		public Minimum_inclusive_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_minimum_inclusive_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterMinimum_inclusive_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitMinimum_inclusive_statement(this);
		}
	}

	[RuleVersion(0)]
	public Minimum_inclusive_statementContext minimum_inclusive_statement() {
		Minimum_inclusive_statementContext _localctx = new Minimum_inclusive_statementContext(Context, State);
		EnterRule(_localctx, 32, RULE_minimum_inclusive_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 160; Match(T__4);
			State = 161;
			_localctx.minval = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==INTEGER || _la==REALNUMBER) ) {
				_localctx.minval = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 162; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_statementContext : ParserRuleContext {
		public ITerminalNode FIELD_TYPE() { return GetToken(IddParser.FIELD_TYPE, 0); }
		public ITerminalNode NEWLINE() { return GetToken(IddParser.NEWLINE, 0); }
		public Type_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterType_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitType_statement(this);
		}
	}

	[RuleVersion(0)]
	public Type_statementContext type_statement() {
		Type_statementContext _localctx = new Type_statementContext(Context, State);
		EnterRule(_localctx, 34, RULE_type_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 164; Match(T__5);
			State = 165; Match(FIELD_TYPE);
			State = 166; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Units_based_on_field_statementContext : ParserRuleContext {
		public ITerminalNode NEWLINE() { return GetToken(IddParser.NEWLINE, 0); }
		public ITerminalNode ALPHA_OPTION() { return GetToken(IddParser.ALPHA_OPTION, 0); }
		public ITerminalNode NUMERIC_OPTION() { return GetToken(IddParser.NUMERIC_OPTION, 0); }
		public Units_based_on_field_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_units_based_on_field_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.EnterUnits_based_on_field_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IIddListener typedListener = listener as IIddListener;
			if (typedListener != null) typedListener.ExitUnits_based_on_field_statement(this);
		}
	}

	[RuleVersion(0)]
	public Units_based_on_field_statementContext units_based_on_field_statement() {
		Units_based_on_field_statementContext _localctx = new Units_based_on_field_statementContext(Context, State);
		EnterRule(_localctx, 36, RULE_units_based_on_field_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 168; Match(T__6);
			State = 169;
			_la = TokenStream.LA(1);
			if ( !(_la==ALPHA_OPTION || _la==NUMERIC_OPTION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 170; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '+', '\xAF', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\a', '\x2', ',', '\n', '\x2', '\f', '\x2', '\xE', '\x2', '/', 
		'\v', '\x2', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x4', '\x3', 
		'\x4', '\x3', '\x4', '\a', '\x4', '\x37', '\n', '\x4', '\f', '\x4', '\xE', 
		'\x4', ':', '\v', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x5', '\a', 
		'\x5', '?', '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\x42', '\v', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', 
		'\a', '\x6', 'I', '\n', '\x6', '\f', '\x6', '\xE', '\x6', 'L', '\v', '\x6', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\a', 
		'\a', 'S', '\n', '\a', '\f', '\a', '\xE', '\a', 'V', '\v', '\a', '\x3', 
		'\a', '\x3', '\a', '\x3', '\b', '\x3', '\b', '\x3', '\t', '\x3', '\t', 
		'\x3', '\t', '\a', '\t', '_', '\n', '\t', '\f', '\t', '\xE', '\t', '\x62', 
		'\v', '\t', '\x3', '\n', '\x3', '\n', '\a', '\n', '\x66', '\n', '\n', 
		'\f', '\n', '\xE', '\n', 'i', '\v', '\n', '\x3', '\v', '\x3', '\v', '\a', 
		'\v', 'm', '\n', '\v', '\f', '\v', '\xE', '\v', 'p', '\v', '\v', '\x3', 
		'\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', 
		'\x3', '\f', '\x5', '\f', 'y', '\n', '\f', '\x3', '\r', '\x3', '\r', '\x3', 
		'\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', 
		'\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', 
		'\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', 
		'\x3', '\r', '\x3', '\r', '\x3', '\r', '\x5', '\r', '\x91', '\n', '\r', 
		'\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xF', 
		'\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\x10', '\x3', '\x10', 
		'\x3', '\x10', '\x3', '\x10', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', 
		'\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x2', '\x2', 
		'\x15', '\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12', 
		'\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', ' ', '\"', '$', '&', '\x2', 
		'\x5', '\x4', '\x2', '\'', '\'', '*', '*', '\x3', '\x2', '$', '%', '\x3', 
		'\x2', '\"', '#', '\x2', '\xC3', '\x2', '-', '\x3', '\x2', '\x2', '\x2', 
		'\x4', '\x30', '\x3', '\x2', '\x2', '\x2', '\x6', '\x33', '\x3', '\x2', 
		'\x2', '\x2', '\b', '@', '\x3', '\x2', '\x2', '\x2', '\n', '\x45', '\x3', 
		'\x2', '\x2', '\x2', '\f', 'O', '\x3', '\x2', '\x2', '\x2', '\xE', 'Y', 
		'\x3', '\x2', '\x2', '\x2', '\x10', '[', '\x3', '\x2', '\x2', '\x2', '\x12', 
		'g', '\x3', '\x2', '\x2', '\x2', '\x14', 'n', '\x3', '\x2', '\x2', '\x2', 
		'\x16', 'x', '\x3', '\x2', '\x2', '\x2', '\x18', '\x90', '\x3', '\x2', 
		'\x2', '\x2', '\x1A', '\x92', '\x3', '\x2', '\x2', '\x2', '\x1C', '\x96', 
		'\x3', '\x2', '\x2', '\x2', '\x1E', '\x9A', '\x3', '\x2', '\x2', '\x2', 
		' ', '\x9E', '\x3', '\x2', '\x2', '\x2', '\"', '\xA2', '\x3', '\x2', '\x2', 
		'\x2', '$', '\xA6', '\x3', '\x2', '\x2', '\x2', '&', '\xAA', '\x3', '\x2', 
		'\x2', '\x2', '(', ',', '\a', '\'', '\x2', '\x2', ')', ',', '\x5', '\x10', 
		'\t', '\x2', '*', ',', '\a', '*', '\x2', '\x2', '+', '(', '\x3', '\x2', 
		'\x2', '\x2', '+', ')', '\x3', '\x2', '\x2', '\x2', '+', '*', '\x3', '\x2', 
		'\x2', '\x2', ',', '/', '\x3', '\x2', '\x2', '\x2', '-', '+', '\x3', '\x2', 
		'\x2', '\x2', '-', '.', '\x3', '\x2', '\x2', '\x2', '.', '\x3', '\x3', 
		'\x2', '\x2', '\x2', '/', '-', '\x3', '\x2', '\x2', '\x2', '\x30', '\x31', 
		'\x5', '\x6', '\x4', '\x2', '\x31', '\x32', '\x5', '\b', '\x5', '\x2', 
		'\x32', '\x5', '\x3', '\x2', '\x2', '\x2', '\x33', '\x34', '\a', '&', 
		'\x2', '\x2', '\x34', '\x38', '\a', '(', '\x2', '\x2', '\x35', '\x37', 
		'\t', '\x2', '\x2', '\x2', '\x36', '\x35', '\x3', '\x2', '\x2', '\x2', 
		'\x37', ':', '\x3', '\x2', '\x2', '\x2', '\x38', '\x36', '\x3', '\x2', 
		'\x2', '\x2', '\x38', '\x39', '\x3', '\x2', '\x2', '\x2', '\x39', ';', 
		'\x3', '\x2', '\x2', '\x2', ':', '\x38', '\x3', '\x2', '\x2', '\x2', ';', 
		'<', '\x5', '\x12', '\n', '\x2', '<', '\a', '\x3', '\x2', '\x2', '\x2', 
		'=', '?', '\x5', '\f', '\a', '\x2', '>', '=', '\x3', '\x2', '\x2', '\x2', 
		'?', '\x42', '\x3', '\x2', '\x2', '\x2', '@', '>', '\x3', '\x2', '\x2', 
		'\x2', '@', '\x41', '\x3', '\x2', '\x2', '\x2', '\x41', '\x43', '\x3', 
		'\x2', '\x2', '\x2', '\x42', '@', '\x3', '\x2', '\x2', '\x2', '\x43', 
		'\x44', '\x5', '\n', '\x6', '\x2', '\x44', '\t', '\x3', '\x2', '\x2', 
		'\x2', '\x45', '\x46', '\x5', '\xE', '\b', '\x2', '\x46', 'J', '\a', ')', 
		'\x2', '\x2', 'G', 'I', '\a', '*', '\x2', '\x2', 'H', 'G', '\x3', '\x2', 
		'\x2', '\x2', 'I', 'L', '\x3', '\x2', '\x2', '\x2', 'J', 'H', '\x3', '\x2', 
		'\x2', '\x2', 'J', 'K', '\x3', '\x2', '\x2', '\x2', 'K', 'M', '\x3', '\x2', 
		'\x2', '\x2', 'L', 'J', '\x3', '\x2', '\x2', '\x2', 'M', 'N', '\x5', '\x14', 
		'\v', '\x2', 'N', '\v', '\x3', '\x2', '\x2', '\x2', 'O', 'P', '\x5', '\xE', 
		'\b', '\x2', 'P', 'T', '\a', '(', '\x2', '\x2', 'Q', 'S', '\a', '*', '\x2', 
		'\x2', 'R', 'Q', '\x3', '\x2', '\x2', '\x2', 'S', 'V', '\x3', '\x2', '\x2', 
		'\x2', 'T', 'R', '\x3', '\x2', '\x2', '\x2', 'T', 'U', '\x3', '\x2', '\x2', 
		'\x2', 'U', 'W', '\x3', '\x2', '\x2', '\x2', 'V', 'T', '\x3', '\x2', '\x2', 
		'\x2', 'W', 'X', '\x5', '\x14', '\v', '\x2', 'X', '\r', '\x3', '\x2', 
		'\x2', '\x2', 'Y', 'Z', '\t', '\x3', '\x2', '\x2', 'Z', '\xF', '\x3', 
		'\x2', '\x2', '\x2', '[', '`', '\a', '\x14', '\x2', '\x2', '\\', '_', 
		'\x5', '\x4', '\x3', '\x2', ']', '_', '\a', '\'', '\x2', '\x2', '^', '\\', 
		'\x3', '\x2', '\x2', '\x2', '^', ']', '\x3', '\x2', '\x2', '\x2', '_', 
		'\x62', '\x3', '\x2', '\x2', '\x2', '`', '^', '\x3', '\x2', '\x2', '\x2', 
		'`', '\x61', '\x3', '\x2', '\x2', '\x2', '\x61', '\x11', '\x3', '\x2', 
		'\x2', '\x2', '\x62', '`', '\x3', '\x2', '\x2', '\x2', '\x63', '\x66', 
		'\x5', '\x16', '\f', '\x2', '\x64', '\x66', '\a', '\'', '\x2', '\x2', 
		'\x65', '\x63', '\x3', '\x2', '\x2', '\x2', '\x65', '\x64', '\x3', '\x2', 
		'\x2', '\x2', '\x66', 'i', '\x3', '\x2', '\x2', '\x2', 'g', '\x65', '\x3', 
		'\x2', '\x2', '\x2', 'g', 'h', '\x3', '\x2', '\x2', '\x2', 'h', '\x13', 
		'\x3', '\x2', '\x2', '\x2', 'i', 'g', '\x3', '\x2', '\x2', '\x2', 'j', 
		'm', '\x5', '\x18', '\r', '\x2', 'k', 'm', '\a', '\'', '\x2', '\x2', 'l', 
		'j', '\x3', '\x2', '\x2', '\x2', 'l', 'k', '\x3', '\x2', '\x2', '\x2', 
		'm', 'p', '\x3', '\x2', '\x2', '\x2', 'n', 'l', '\x3', '\x2', '\x2', '\x2', 
		'n', 'o', '\x3', '\x2', '\x2', '\x2', 'o', '\x15', '\x3', '\x2', '\x2', 
		'\x2', 'p', 'n', '\x3', '\x2', '\x2', '\x2', 'q', 'y', '\a', '\x10', '\x2', 
		'\x2', 'r', 'y', '\a', '\x13', '\x2', '\x2', 's', 'y', '\a', '\x17', '\x2', 
		'\x2', 't', 'y', '\x5', '\x1E', '\x10', '\x2', 'u', 'y', '\a', '\x1A', 
		'\x2', '\x2', 'v', 'y', '\a', '\x1E', '\x2', '\x2', 'w', 'y', '\a', ' ', 
		'\x2', '\x2', 'x', 'q', '\x3', '\x2', '\x2', '\x2', 'x', 'r', '\x3', '\x2', 
		'\x2', '\x2', 'x', 's', '\x3', '\x2', '\x2', '\x2', 'x', 't', '\x3', '\x2', 
		'\x2', '\x2', 'x', 'u', '\x3', '\x2', '\x2', '\x2', 'x', 'v', '\x3', '\x2', 
		'\x2', '\x2', 'x', 'w', '\x3', '\x2', '\x2', '\x2', 'y', '\x17', '\x3', 
		'\x2', '\x2', '\x2', 'z', '\x91', '\a', '\v', '\x2', '\x2', '{', '\x91', 
		'\a', '\f', '\x2', '\x2', '|', '\x91', '\a', '\r', '\x2', '\x2', '}', 
		'\x91', '\a', '\xE', '\x2', '\x2', '~', '\x91', '\a', '\xF', '\x2', '\x2', 
		'\x7F', '\x91', '\a', '\x11', '\x2', '\x2', '\x80', '\x91', '\a', '\x12', 
		'\x2', '\x2', '\x81', '\x91', '\a', '\x15', '\x2', '\x2', '\x82', '\x91', 
		'\a', '\x16', '\x2', '\x2', '\x83', '\x91', '\x5', '\x1C', '\xF', '\x2', 
		'\x84', '\x91', '\x5', '\x1A', '\xE', '\x2', '\x85', '\x91', '\x5', '\"', 
		'\x12', '\x2', '\x86', '\x91', '\x5', ' ', '\x11', '\x2', '\x87', '\x91', 
		'\a', '\x18', '\x2', '\x2', '\x88', '\x91', '\a', '\x19', '\x2', '\x2', 
		'\x89', '\x91', '\a', '\x1B', '\x2', '\x2', '\x8A', '\x91', '\a', '\x1C', 
		'\x2', '\x2', '\x8B', '\x91', '\a', '\x1D', '\x2', '\x2', '\x8C', '\x91', 
		'\a', '\x1F', '\x2', '\x2', '\x8D', '\x91', '\x5', '$', '\x13', '\x2', 
		'\x8E', '\x91', '\a', '!', '\x2', '\x2', '\x8F', '\x91', '\x5', '&', '\x14', 
		'\x2', '\x90', 'z', '\x3', '\x2', '\x2', '\x2', '\x90', '{', '\x3', '\x2', 
		'\x2', '\x2', '\x90', '|', '\x3', '\x2', '\x2', '\x2', '\x90', '}', '\x3', 
		'\x2', '\x2', '\x2', '\x90', '~', '\x3', '\x2', '\x2', '\x2', '\x90', 
		'\x7F', '\x3', '\x2', '\x2', '\x2', '\x90', '\x80', '\x3', '\x2', '\x2', 
		'\x2', '\x90', '\x81', '\x3', '\x2', '\x2', '\x2', '\x90', '\x82', '\x3', 
		'\x2', '\x2', '\x2', '\x90', '\x83', '\x3', '\x2', '\x2', '\x2', '\x90', 
		'\x84', '\x3', '\x2', '\x2', '\x2', '\x90', '\x85', '\x3', '\x2', '\x2', 
		'\x2', '\x90', '\x86', '\x3', '\x2', '\x2', '\x2', '\x90', '\x87', '\x3', 
		'\x2', '\x2', '\x2', '\x90', '\x88', '\x3', '\x2', '\x2', '\x2', '\x90', 
		'\x89', '\x3', '\x2', '\x2', '\x2', '\x90', '\x8A', '\x3', '\x2', '\x2', 
		'\x2', '\x90', '\x8B', '\x3', '\x2', '\x2', '\x2', '\x90', '\x8C', '\x3', 
		'\x2', '\x2', '\x2', '\x90', '\x8D', '\x3', '\x2', '\x2', '\x2', '\x90', 
		'\x8E', '\x3', '\x2', '\x2', '\x2', '\x90', '\x8F', '\x3', '\x2', '\x2', 
		'\x2', '\x91', '\x19', '\x3', '\x2', '\x2', '\x2', '\x92', '\x93', '\a', 
		'\x3', '\x2', '\x2', '\x93', '\x94', '\t', '\x4', '\x2', '\x2', '\x94', 
		'\x95', '\a', '*', '\x2', '\x2', '\x95', '\x1B', '\x3', '\x2', '\x2', 
		'\x2', '\x96', '\x97', '\a', '\x4', '\x2', '\x2', '\x97', '\x98', '\t', 
		'\x4', '\x2', '\x2', '\x98', '\x99', '\a', '*', '\x2', '\x2', '\x99', 
		'\x1D', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x9B', '\a', '\x5', '\x2', 
		'\x2', '\x9B', '\x9C', '\a', '\"', '\x2', '\x2', '\x9C', '\x9D', '\a', 
		'*', '\x2', '\x2', '\x9D', '\x1F', '\x3', '\x2', '\x2', '\x2', '\x9E', 
		'\x9F', '\a', '\x6', '\x2', '\x2', '\x9F', '\xA0', '\t', '\x4', '\x2', 
		'\x2', '\xA0', '\xA1', '\a', '*', '\x2', '\x2', '\xA1', '!', '\x3', '\x2', 
		'\x2', '\x2', '\xA2', '\xA3', '\a', '\a', '\x2', '\x2', '\xA3', '\xA4', 
		'\t', '\x4', '\x2', '\x2', '\xA4', '\xA5', '\a', '*', '\x2', '\x2', '\xA5', 
		'#', '\x3', '\x2', '\x2', '\x2', '\xA6', '\xA7', '\a', '\b', '\x2', '\x2', 
		'\xA7', '\xA8', '\a', '\n', '\x2', '\x2', '\xA8', '\xA9', '\a', '*', '\x2', 
		'\x2', '\xA9', '%', '\x3', '\x2', '\x2', '\x2', '\xAA', '\xAB', '\a', 
		'\t', '\x2', '\x2', '\xAB', '\xAC', '\t', '\x3', '\x2', '\x2', '\xAC', 
		'\xAD', '\a', '*', '\x2', '\x2', '\xAD', '\'', '\x3', '\x2', '\x2', '\x2', 
		'\x10', '+', '-', '\x38', '@', 'J', 'T', '^', '`', '\x65', 'g', 'l', 'n', 
		'x', '\x90',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
